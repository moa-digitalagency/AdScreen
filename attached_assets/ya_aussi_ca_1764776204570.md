<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# ya aussi ca

Oui, c'est le m√™me probl√®me: **FragLoadError** = Les fragments HLS ne se chargent pas.

```
HLS Error: networkError - FragLoadError
```

**Le probl√®me est clair maintenant:** FFmpeg g√©n√®re un manifeste `.m3u8` mais **les segments ne peuvent pas √™tre servis correctement**.

## Solution d√©finitive - Sauvegarde les segments sur disque:

**Remplace `services/hls_converter.py` par ceci:**

```python
import subprocess
import os
import tempfile
import logging
import threading
import shutil
from pathlib import Path

logger = logging.getLogger(__name__)

class HLSConverter:
    # Dossier temporaire global pour les segments HLS
    HLS_TEMP_DIR = Path(tempfile.gettempdir()) / 'adscreen_hls'
    
    def __init__(self):
        self.HLS_TEMP_DIR.mkdir(parents=True, exist_ok=True)
    
    @staticmethod
    def convert_mpegts_to_hls_file(source_url, screen_code):
        """
        Convertit MPEG-TS en HLS et sauvegarde les segments sur disque
        Retourne le chemin du fichier M3U8
        """
        
        output_dir = HLSConverter.HLS_TEMP_DIR / screen_code
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Nettoyer les anciens segments
        for f in output_dir.glob('*.ts'):
            try:
                f.unlink()
            except:
                pass
        
        manifest_path = output_dir / 'stream.m3u8'
        
        cmd = [
            'ffmpeg',
            '-rtsp_transport', 'tcp',
            '-timeout', '30000000',
            '-i', source_url,
            '-c:v', 'copy',
            '-c:a', 'aac',
            '-b:a', '128k',
            '-f', 'hls',
            '-hls_time', '4',
            '-hls_list_size', '5',
            '-hls_flags', 'delete_segments+live_start+independent_segments',
            '-flvflags', 'no_duration_filesize',
            str(manifest_path)
        ]
        
        try:
            logger.info(f'[{screen_code}] Starting FFmpeg conversion to {output_dir}')
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            
            # Lancer en background
            def monitor_process():
                stdout, stderr = process.communicate()
                if process.returncode != 0:
                    logger.error(f'[{screen_code}] FFmpeg error: {stderr.decode()[:500]}')
            
            thread = threading.Thread(target=monitor_process, daemon=True)
            thread.start()
            
            # Attendre que le manifeste soit cr√©√©
            import time
            for _ in range(30):
                if manifest_path.exists():
                    logger.info(f'[{screen_code}] ‚úì Manifest created')
                    return str(manifest_path)
                time.sleep(0.1)
            
            logger.error(f'[{screen_code}] Manifest not created after 3s')
            raise Exception('Manifest creation timeout')
        
        except Exception as e:
            logger.error(f'[{screen_code}] Conversion error: {e}')
            raise
```

**Dans `routes/player_routes.py`, change la route:**

```python
from flask import send_file
from services.hls_converter import HLSConverter
import logging

logger = logging.getLogger(__name__)

@player_bp.route('/tv-stream/<screen_code>', methods=['GET'])
def tv_stream(screen_code):
    """Stream MPEG-TS as HLS - saved to disk"""
    
    try:
        screen = Screen.query.filter_by(code=screen_code).first()
        
        if not screen or not screen.current_iptv_channel:
            return {'error': 'Invalid screen or no IPTV channel'}, 404
        
        logger.info(f'[{screen_code}] TV stream requested')
        
        try:
            # Convertir et obtenir le chemin du manifeste
            manifest_path = HLSConverter.convert_mpegts_to_hls_file(
                screen.current_iptv_channel,
                screen_code
            )
            
            # Lire et retourner le manifeste
            with open(manifest_path, 'r') as f:
                manifest_content = f.read()
            
            logger.info(f'[{screen_code}] Manifest ready:\n{manifest_content[:200]}')
            
            # Retourner le manifeste avec les bonnes headers
            from flask import Response
            return Response(
                manifest_content,
                mimetype='application/x-mpegURL',
                headers={
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                }
            )
        
        except Exception as e:
            logger.error(f'[{screen_code}] Stream error: {e}')
            return {'error': str(e)}, 500
    
    except Exception as e:
        logger.exception(f'Unexpected error: {e}')
        return {'error': 'Internal error'}, 500

@player_bp.route('/tv-segment/<screen_code>/<segment_name>', methods=['GET'])
def tv_segment(screen_code, segment_name):
    """Serve HLS segments (.ts files)"""
    
    try:
        segment_path = HLSConverter.HLS_TEMP_DIR / screen_code / segment_name
        
        if not segment_path.exists():
            logger.warning(f'[{screen_code}] Segment not found: {segment_name}')
            return {'error': 'Segment not found'}, 404
        
        return send_file(
            segment_path,
            mimetype='video/mp2t',
            as_attachment=False,
            cache_timeout=3600
        )
    
    except Exception as e:
        logger.error(f'Segment error: {e}')
        return {'error': 'Segment error'}, 500
```

**Dans `templates/player.html`, modifie le chemin:**

```javascript
// Modifier les URLs des segments dans le manifeste
const streamUrl = `/player/tv-stream/${screenCode}`;

// Intercepter et modifier les requ√™tes de segments
const originalXHR = XMLHttpRequest.prototype.open;
XMLHttpRequest.prototype.open = function(method, url, ...args) {
    if (url.includes('.ts') && !url.includes('/player/')) {
        // R√©√©crire les URLs des segments
        const filename = url.split('/').pop();
        url = `/player/tv-segment/${screenCode}/${filename}`;
    }
    return originalXHR.call(this, method, url, ...args);
};
```

Ou plus simplement, **modifie le manifeste avant de le retourner:**

```python
@player_bp.route('/tv-stream/<screen_code>', methods=['GET'])
def tv_stream(screen_code):
    # ... code pr√©c√©dent ...
    
    with open(manifest_path, 'r') as f:
        manifest_content = f.read()
    
    # Remplacer les URLs des segments locaux par les URLs du serveur
    import re
    manifest_content = re.sub(
        r'(stream\d+\.ts)',
        f'/player/tv-segment/{screen_code}/\\1',
        manifest_content
    )
    
    logger.info(f'[{screen_code}] Modified manifest:\n{manifest_content}')
    
    from flask import Response
    return Response(
        manifest_content,
        mimetype='application/x-mpegURL',
        headers={'Cache-Control': 'no-cache, no-store, must-revalidate'}
    )
```


***

## Checklist:

1. **Remplace `services/hls_converter.py`** avec le code ci-dessus
2. **Mets √† jour `routes/player_routes.py`** - ajoute les 2 routes (tv-stream + tv-segment)
3. **Teste les logs** pour voir les segments g√©n√©r√©s
4. **Push et red√©marre:**
```bash
git add .
git commit -m "Fix: Save HLS segments to disk with proper manifest rewriting"
git push
gunicorn --bind 0.0.0.0:5000 --reload main:app
```

**√áa devrait marcher maintenant!** üéâ
<span style="display:none">[^1]</span>

<div align="center">‚ÅÇ</div>

[^1]: image.jpg

