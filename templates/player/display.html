<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ screen.name }} - Shabaka AdScreen Player</title>
    <link rel="icon" type="image/svg+xml" href="/static/favicon-player.svg">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            cursor: none;
        }
        
        body.show-controls {
            cursor: default;
        }
        
        #player {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background: #000;
        }
        
        #player img,
        #player video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
            pointer-events: none;
        }
        
        body.show-controls #controls {
            opacity: 1;
            pointer-events: auto;
        }
        
        .control-btn {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-family: sans-serif;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .control-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        
        #status {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 20px;
            color: white;
            font-family: sans-serif;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        body.show-controls #status {
            opacity: 1;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        .status-playing { background: #22c55e; }
        .status-paused { background: #eab308; }
        .status-offline { background: #ef4444; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-family: sans-serif;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        body.show-controls #info {
            opacity: 1;
        }
        
        .overlay-header, .overlay-footer {
            position: fixed;
            left: 0;
            right: 0;
            z-index: 50;
            overflow: hidden;
        }
        
        .overlay-header { top: 0; }
        .overlay-footer { bottom: 0; }
        
        .overlay-ticker {
            white-space: nowrap;
            display: inline-block;
            padding: 12px 0;
            animation: ticker linear infinite;
        }
        
        @keyframes ticker {
            0% { transform: translateX(100vw); }
            100% { transform: translateX(-100%); }
        }
        
        .overlay-image {
            width: 100%;
            height: auto;
            object-fit: contain;
        }
        
        .overlay-body {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
        }
        
        #startScreen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #1e3a5f 0%, #0f172a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-family: sans-serif;
            z-index: 200;
        }
        
        #startScreen.hidden {
            display: none;
        }
        
        #startBtn {
            background: #3b82f6;
            border: none;
            color: white;
            padding: 20px 40px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 30px;
            transition: transform 0.2s, background 0.2s;
        }
        
        #startBtn:hover {
            background: #2563eb;
            transform: scale(1.05);
        }
        
        .loading {
            position: fixed;
            inset: 0;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 150;
        }
        
        .loading.hidden {
            display: none;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #debugInfo {
            position: fixed;
            top: 60px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: #0f0;
            font-family: monospace;
            font-size: 10px;
            padding: 10px;
            border-radius: 4px;
            max-width: 300px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        body.show-controls #debugInfo {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <svg width="80" height="80" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="2" y="7" width="20" height="15" rx="2" ry="2"/>
            <polyline points="17,2 12,7 7,2"/>
        </svg>
        <h1 style="font-size: 28px; margin-top: 20px;">{{ screen.name }}</h1>
        <p style="color: rgba(255,255,255,0.6); margin-top: 8px;">{{ screen.resolution_width }}x{{ screen.resolution_height }} - {{ screen.orientation }}</p>
        <button id="startBtn" onclick="startPlayer()">
            ‚ñ∂ Lancer la playlist
        </button>
        <p style="color: rgba(255,255,255,0.4); margin-top: 30px; font-size: 12px;">
            Appuyez sur F11 pour le mode plein √©cran
        </p>
    </div>

    <div id="loading" class="loading hidden">
        <div class="spinner"></div>
    </div>

    <div id="overlayHeader" class="overlay-header" style="display: none;"></div>
    <div id="overlayBody" class="overlay-body" style="display: none;"></div>
    <div id="overlayTopLeft" class="overlay-corner" style="display: none; position: fixed; top: 10px; left: 10px; z-index: 50;"></div>
    <div id="overlayTopRight" class="overlay-corner" style="display: none; position: fixed; top: 10px; right: 10px; z-index: 50;"></div>
    <div id="overlayBottomLeft" class="overlay-corner" style="display: none; position: fixed; bottom: 10px; left: 10px; z-index: 50;"></div>
    <div id="overlayBottomRight" class="overlay-corner" style="display: none; position: fixed; bottom: 10px; right: 10px; z-index: 50;"></div>
    <div id="overlayCustom" class="overlay-custom" style="display: none; position: fixed; z-index: 50;"></div>
    
    <div id="player">
        <img id="imageContent" style="display: none;" />
        <video id="videoContent" style="display: none;" muted playsinline></video>
        <video id="iptvContent" style="display: none;" autoplay muted playsinline></video>
    </div>
    
    <div id="iptvInfo" style="display: none; position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.7); backdrop-filter: blur(10px); padding: 12px 20px; border-radius: 8px; color: white; font-family: sans-serif; font-size: 14px; z-index: 60;">
        <div style="display: flex; align-items: center; gap: 8px;">
            <span style="color: #a855f7;">üì∫</span>
            <span id="iptvChannelName">OnlineTV</span>
        </div>
    </div>
    
    <script src="{{ url_for('static', filename='js/hls.min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/mpegts.min.js') }}"></script>
    
    <div id="overlayFooter" class="overlay-footer" style="display: none;"></div>

    <div id="status">
        <span class="status-dot status-playing" id="statusDot"></span>
        <span id="statusText">En ligne</span>
    </div>

    <div id="info">
        <div id="currentInfo">En attente...</div>
        <div id="nextInfo" style="color: rgba(255,255,255,0.5); margin-top: 4px;"></div>
    </div>

    <div id="debugInfo"></div>

    <div id="controls">
        <button class="control-btn" onclick="togglePause()">
            <span id="pauseIcon">‚è∏</span> Pause
        </button>
        <button class="control-btn" onclick="toggleFullscreen()">
            ‚õ∂ Plein √©cran
        </button>
        <button class="control-btn" onclick="logout()">
            ‚èª D√©connecter
        </button>
    </div>

    <script>
        const PlayerState = {
            IDLE: 'idle',
            PLAYING: 'playing',
            PAUSED: 'paused',
            TRANSITIONING: 'transitioning'
        };

        const player = {
            playlist: [],
            overlays: [],
            currentIndex: 0,
            state: PlayerState.IDLE,
            mode: 'playlist',
            iptvUrl: null,
            iptvChannelName: null,
            screenCode: '{{ screen.unique_code }}',
            timerId: null,
            heartbeatInterval: null,
            refreshInterval: null,
            controlsTimeout: null,
            currentItemStartTime: null,
            hlsInstance: null,
            mpegtsPlayer: null,
            
            CONTROLS_HIDE_DELAY: 10000,
            PLAYLIST_REFRESH_INTERVAL: 10000,
            MIN_DISPLAY_TIME: 1000,
            
            imageEl: null,
            videoEl: null,
            iptvEl: null,
            debugEl: null
        };

        function debug(msg) {
            console.log('[Player]', msg);
            if (player.debugEl) {
                const time = new Date().toLocaleTimeString();
                player.debugEl.innerHTML = `[${time}] ${msg}<br>` + 
                    (player.debugEl.innerHTML || '').split('<br>').slice(0, 10).join('<br>');
            }
        }

        function showControls() {
            document.body.classList.add('show-controls');
            clearTimeout(player.controlsTimeout);
            player.controlsTimeout = setTimeout(() => {
                document.body.classList.remove('show-controls');
            }, player.CONTROLS_HIDE_DELAY);
        }

        function clearTimer() {
            if (player.timerId) {
                clearTimeout(player.timerId);
                player.timerId = null;
            }
        }

        function scheduleNext(delayMs) {
            clearTimer();
            debug(`Scheduling next in ${delayMs}ms`);
            player.timerId = setTimeout(() => {
                advanceToNext();
            }, delayMs);
        }

        function advanceToNext() {
            if (player.state === PlayerState.PAUSED) {
                debug('Paused, not advancing');
                return;
            }
            
            if (player.playlist.length === 0) {
                debug('Empty playlist, waiting...');
                player.state = PlayerState.IDLE;
                updateInfoDisplay(null);
                return;
            }
            
            player.state = PlayerState.TRANSITIONING;
            clearTimer();
            
            player.currentIndex = (player.currentIndex + 1) % player.playlist.length;
            debug(`Advancing to index ${player.currentIndex} of ${player.playlist.length}`);
            
            playCurrentItem();
        }

        function playCurrentItem() {
            if (player.state === PlayerState.PAUSED) {
                debug('Paused, not playing');
                return;
            }
            
            if (player.playlist.length === 0) {
                debug('No items to play');
                player.state = PlayerState.IDLE;
                updateInfoDisplay(null);
                return;
            }
            
            const item = player.playlist[player.currentIndex];
            if (!item) {
                debug('Invalid item at index ' + player.currentIndex);
                player.currentIndex = 0;
                if (player.playlist.length > 0) {
                    setTimeout(() => playCurrentItem(), 100);
                }
                return;
            }
            
            player.state = PlayerState.PLAYING;
            player.currentItemStartTime = Date.now();
            
            const duration = Math.max(3, parseInt(item.duration) || 10);
            debug(`Playing: ${item.category}/${item.name || item.id} for ${duration}s`);
            
            updateInfoDisplay(item);
            
            if (item.type === 'image') {
                playImage(item, duration);
            } else if (item.type === 'video') {
                playVideo(item, duration);
            } else {
                debug('Unknown content type: ' + item.type);
                scheduleNext(1000);
            }
        }

        function playImage(item, duration) {
            player.videoEl.pause();
            player.videoEl.removeAttribute('src');
            player.videoEl.style.display = 'none';
            
            player.imageEl.style.display = 'block';
            player.imageEl.src = item.url;
            
            player.imageEl.onload = () => {
                debug('Image loaded: ' + item.url);
                logPlay(item);
            };
            
            player.imageEl.onerror = () => {
                debug('Image error: ' + item.url);
                scheduleNext(500);
            };
            
            scheduleNext(duration * 1000);
        }

        function playVideo(item, duration) {
            player.imageEl.style.display = 'none';
            
            player.videoEl.onended = null;
            player.videoEl.onerror = null;
            player.videoEl.onloadeddata = null;
            player.videoEl.ontimeupdate = null;
            
            player.videoEl.style.display = 'block';
            player.videoEl.src = item.url;
            player.videoEl.currentTime = 0;
            player.videoEl.loop = false;
            
            let hasLogged = false;
            let videoEnded = false;
            const slotDuration = duration * 1000;
            const startTime = Date.now();
            
            const handleVideoEnd = () => {
                if (videoEnded) return;
                videoEnded = true;
                
                const videoDuration = player.videoEl.duration || 0;
                const elapsedTime = Date.now() - startTime;
                const remainingSlotTime = slotDuration - elapsedTime;
                
                if (remainingSlotTime > 100) {
                    debug(`Video ended (${videoDuration.toFixed(1)}s), keeping last frame for ${(remainingSlotTime/1000).toFixed(1)}s to complete ${duration}s slot`);
                    player.videoEl.pause();
                } else {
                    debug('Video ended, slot duration reached');
                }
            };
            
            player.videoEl.onloadeddata = () => {
                const videoDuration = player.videoEl.duration || 0;
                debug(`Video loaded, video duration: ${videoDuration.toFixed(1)}s, slot duration: ${duration}s`);
                
                if (videoDuration < duration) {
                    debug(`Video shorter than slot (${videoDuration.toFixed(1)}s < ${duration}s) - will hold last frame`);
                }
                
                player.videoEl.play().then(() => {
                    if (!hasLogged) {
                        hasLogged = true;
                        logPlay(item);
                    }
                }).catch(e => {
                    debug('Video play error: ' + e.message);
                    scheduleNext(500);
                });
            };
            
            player.videoEl.onended = handleVideoEnd;
            
            player.videoEl.onerror = (e) => {
                debug('Video error: ' + (e.message || 'unknown'));
                scheduleNext(500);
            };
            
            player.videoEl.ontimeupdate = () => {
                if (!videoEnded && player.videoEl.currentTime >= player.videoEl.duration - 0.1) {
                    handleVideoEnd();
                }
            };
            
            scheduleNext(slotDuration);
        }

        function updateInfoDisplay(item) {
            const currentInfoEl = document.getElementById('currentInfo');
            const nextInfoEl = document.getElementById('nextInfo');
            
            if (!item) {
                currentInfoEl.textContent = 'Aucun contenu disponible';
                nextInfoEl.textContent = 'En attente de nouveaux contenus...';
                return;
            }
            
            const categoryLabels = {
                'paid': 'üí∞ Publicit√©',
                'internal': 'üì¢ Promo',
                'filler': 'üé¨ D√©mo'
            };
            
            const itemName = item.name || 'Contenu';
            currentInfoEl.innerHTML = 
                `<strong>${categoryLabels[item.category] || item.category}</strong> - ${itemName}<br>
                 <span style="opacity: 0.7">Dur√©e: ${item.duration}s ${item.remaining_plays ? `| Restant: ${item.remaining_plays}` : ''}</span>`;
            
            if (player.playlist.length > 1) {
                const nextIndex = (player.currentIndex + 1) % player.playlist.length;
                const nextItem = player.playlist[nextIndex];
                nextInfoEl.textContent = 
                    `Suivant: ${categoryLabels[nextItem.category] || nextItem.category} - ${nextItem.name || 'Contenu'}`;
            } else {
                nextInfoEl.textContent = 'Boucle en cours...';
            }
        }

        async function fetchPlaylist() {
            try {
                const response = await fetch('/player/api/playlist');
                const data = await response.json();
                
                if (data.error) {
                    debug('Playlist error: ' + data.error);
                    return;
                }
                
                const newMode = data.mode || 'playlist';
                const previousMode = player.mode;
                
                if (newMode === 'iptv' && data.iptv) {
                    player.mode = 'iptv';
                    const newIptvUrl = data.iptv.url;
                    const channelName = data.iptv.name;
                    
                    console.log('[IPTV DEBUG] Current URL:', player.iptvUrl);
                    console.log('[IPTV DEBUG] New URL:', newIptvUrl);
                    console.log('[IPTV DEBUG] Channel:', channelName);
                    console.log('[IPTV DEBUG] Previous mode:', previousMode);
                    console.log('[IPTV DEBUG] URLs equal:', player.iptvUrl === newIptvUrl);
                    
                    if (previousMode !== 'iptv' || player.iptvUrl !== newIptvUrl) {
                        console.log('[IPTV DEBUG] *** SWITCHING CHANNEL ***');
                        debug(`Switching to OnlineTV mode: ${channelName}`);
                        player.iptvUrl = newIptvUrl;
                        player.iptvChannelName = channelName;
                        switchToIptvMode();
                    } else {
                        console.log('[IPTV DEBUG] Same channel, no switch needed');
                    }
                    return;
                }
                
                if (previousMode === 'iptv' && newMode === 'playlist') {
                    debug('Switching from OnlineTV to playlist mode');
                    switchToPlaylistMode();
                }
                
                player.mode = 'playlist';
                const newPlaylist = data.playlist || [];
                player.overlays = data.overlays || [];
                
                if (player.playlist.length !== newPlaylist.length) {
                    debug(`Playlist updated: ${player.playlist.length} -> ${newPlaylist.length} items`);
                }
                
                if (player.currentIndex >= newPlaylist.length && newPlaylist.length > 0) {
                    player.currentIndex = 0;
                }
                
                player.playlist = newPlaylist;
                renderOverlays();
                
                if (player.state === PlayerState.IDLE && player.playlist.length > 0) {
                    debug('Starting playback from idle');
                    player.currentIndex = 0;
                    playCurrentItem();
                }
                
                if (player.playlist.length === 0) {
                    updateInfoDisplay(null);
                }
            } catch (error) {
                debug('Fetch playlist error: ' + error.message);
            }
        }
        
        async function switchToIptvMode() {
            console.log('[IPTV DEBUG] switchToIptvMode() called');
            console.log('[IPTV DEBUG] Current player.iptvUrl:', player.iptvUrl);
            console.log('[IPTV DEBUG] Current player.iptvChannelName:', player.iptvChannelName);
            
            clearTimer();
            
            player.imageEl.style.display = 'none';
            player.videoEl.pause();
            player.videoEl.style.display = 'none';
            
            if (player.hlsInstance) {
                console.log('[IPTV DEBUG] Destroying existing HLS instance');
                player.hlsInstance.destroy();
                player.hlsInstance = null;
            }
            
            if (player.mpegtsPlayer) {
                console.log('[IPTV DEBUG] Destroying existing MPEG-TS player');
                player.mpegtsPlayer.destroy();
                player.mpegtsPlayer = null;
            }
            
            try {
                console.log('[IPTV DEBUG] Stopping previous stream on server...');
                debug('Stopping previous stream on server...');
                await fetch('/player/tv-stop/' + player.screenCode, { method: 'POST' });
                console.log('[IPTV DEBUG] Previous stream stopped, waiting 500ms...');
                debug('Previous stream stopped');
                await new Promise(resolve => setTimeout(resolve, 500));
            } catch (e) {
                console.log('[IPTV DEBUG] Stop request error:', e.message);
                debug('Stop request error (continuing): ' + e.message);
            }
            
            player.iptvEl.style.display = 'block';
            player.iptvRetryCount = 0;
            player.iptvMaxRetries = 3;
            player.iptvRetryDelay = 2000;
            player.useProxy = false;
            player.originalIptvUrl = player.iptvUrl;
            
            let streamUrl = player.iptvUrl;
            debug('OnlineTV URL: ' + streamUrl);
            
            updateIptvStatus('loading', 'Connexion...');
            
            if (isHlsStream(streamUrl)) {
                debug('Detected HLS stream (.m3u8), using hls.js');
                loadHlsStream(streamUrl, false);
            } else {
                debug('Detected MPEG-TS stream, using mpegts.js via proxy');
                loadMpegTsStream(streamUrl, true);
            }
        }
        
        function isHlsStream(url) {
            const lowerUrl = url.toLowerCase();
            return lowerUrl.includes('.m3u8') || lowerUrl.includes('output=m3u8');
        }
        
        function loadMpegTsStream(streamUrl, useHlsConvert = false) {
            if (player.hlsInstance) {
                player.hlsInstance.destroy();
                player.hlsInstance = null;
            }
            
            if (player.mpegtsPlayer) {
                player.mpegtsPlayer.destroy();
                player.mpegtsPlayer = null;
            }
            
            player.iptvEl.src = '';
            player.iptvEl.load();
            
            const hlsConvertUrl = '/player/tv-stream/' + player.screenCode + '?t=' + Date.now();
            player.useProxy = useHlsConvert;
            
            if (useHlsConvert) {
                debug('Loading MPEG-TS via HLS conversion: ' + hlsConvertUrl);
                updateIptvStatus('loading', 'Conversion HLS...');
                loadHlsStream(hlsConvertUrl, false);
                return;
            }
            
            const effectiveUrl = streamUrl;
            debug('Loading MPEG-TS stream directly: ' + effectiveUrl);
            updateIptvStatus('loading', 'Chargement MPEG-TS...');
            
            if (typeof mpegts !== 'undefined' && mpegts.isSupported()) {
                debug('Using mpegts.js for MPEG-TS stream');
                
                player.mpegtsPlayer = mpegts.createPlayer({
                    type: 'mpegts',
                    isLive: true,
                    url: effectiveUrl
                }, {
                    enableWorker: true,
                    enableStashBuffer: false,
                    stashInitialSize: 128,
                    liveBufferLatencyChasing: true,
                    liveBufferLatencyMaxLatency: 1.5,
                    liveBufferLatencyMinRemain: 0.3,
                    lazyLoad: false,
                    lazyLoadMaxDuration: 0,
                    deferLoadAfterSourceOpen: false
                });
                
                player.mpegtsPlayer.attachMediaElement(player.iptvEl);
                player.mpegtsPlayer.load();
                
                player.mpegtsPlayer.on(mpegts.Events.ERROR, function(errorType, errorDetail, errorInfo) {
                    debug('MPEG-TS error: ' + errorType + ' - ' + errorDetail);
                    if (!useHlsConvert && player.iptvRetryCount < player.iptvMaxRetries) {
                        player.iptvRetryCount++;
                        debug('Retrying via HLS conversion (attempt ' + player.iptvRetryCount + ')');
                        updateIptvStatus('retrying', 'Reconnexion via conversion HLS...');
                        setTimeout(() => loadMpegTsStream(streamUrl, true), 1000);
                    } else {
                        updateIptvStatus('error', 'Lecture impossible');
                        showIptvError('Impossible de lire le flux MPEG-TS. Le serveur peut bloquer les connexions externes ou le flux n\'est pas disponible.');
                    }
                });
                
                player.mpegtsPlayer.on(mpegts.Events.LOADING_COMPLETE, function() {
                    debug('MPEG-TS loading complete');
                });
                
                player.mpegtsPlayer.on(mpegts.Events.RECOVERED_EARLY_EOF, function() {
                    debug('MPEG-TS recovered from early EOF');
                });
                
                player.mpegtsPlayer.on(mpegts.Events.MEDIA_INFO, function(mediaInfo) {
                    debug('MPEG-TS media info received');
                });
                
                const playPromise = player.iptvEl.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        debug('MPEG-TS stream started (direct)');
                        player.state = PlayerState.PLAYING;
                        player.iptvRetryCount = 0;
                        hideIptvError();
                        updateIptvStatus('playing', player.iptvChannelName || 'OnlineTV');
                    }).catch(e => {
                        debug('MPEG-TS play error: ' + e.message);
                        if (!useHlsConvert) {
                            player.iptvRetryCount++;
                            debug('Retrying via HLS conversion...');
                            updateIptvStatus('retrying', 'Reconnexion via conversion HLS...');
                            setTimeout(() => loadMpegTsStream(streamUrl, true), 1000);
                        } else {
                            updateIptvStatus('error', 'Lecture impossible');
                        }
                    });
                }
            } else {
                debug('mpegts.js not supported, trying HLS conversion');
                loadMpegTsStream(streamUrl, true);
            }
            
            player.iptvEl.onerror = function(e) {
                debug('MPEG-TS video error: ' + (e.message || 'Unknown error'));
                if (!useHlsConvert) {
                    debug('Trying HLS conversion...');
                    loadMpegTsStream(streamUrl, true);
                } else {
                    updateIptvStatus('error', 'Erreur de flux');
                }
            };
        }
        
        function getProxyUrl(originalUrl) {
            return '/player/api/stream-proxy?url=' + encodeURIComponent(originalUrl);
        }
        
        function loadHlsStream(streamUrl, useProxy = false) {
            if (player.hlsInstance) {
                player.hlsInstance.destroy();
                player.hlsInstance = null;
            }
            
            player.iptvEl.src = '';
            player.iptvEl.load();
            
            let effectiveUrl = useProxy ? getProxyUrl(streamUrl) : streamUrl;
            if (effectiveUrl.includes('?')) {
                effectiveUrl += '&t=' + Date.now();
            } else {
                effectiveUrl += '?t=' + Date.now();
            }
            player.useProxy = useProxy;
            
            if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                debug('Using HLS.js for OnlineTV stream (attempt ' + (player.iptvRetryCount + 1) + ', proxy: ' + useProxy + ')');
                player.hlsInstance = new Hls({
                    debug: false,
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 30,
                    maxBufferLength: 10,
                    maxMaxBufferLength: 30,
                    maxBufferSize: 30 * 1000 * 1000,
                    maxBufferHole: 0.5,
                    fragLoadingTimeOut: 20000,
                    manifestLoadingTimeOut: 15000,
                    levelLoadingTimeOut: 15000,
                    startFragPrefetch: true,
                    startLevel: 0,
                    abrMaxWithRealBitrate: true,
                    manifestLoadingMaxRetry: 5,
                    fragLoadingMaxRetry: 5,
                    fragLoadingRetryDelay: 1000,
                    levelLoadingMaxRetry: 4,
                    xhrSetup: function(xhr, url) {
                        xhr.withCredentials = false;
                    }
                });
                
                player.hlsInstance.loadSource(effectiveUrl);
                player.hlsInstance.attachMedia(player.iptvEl);
                player.hlsInstance.startLoad();
                
                player.hlsInstance.on(Hls.Events.MANIFEST_PARSED, function() {
                    debug('HLS manifest parsed, starting playback');
                    player.iptvRetryCount = 0;
                    hideIptvError();
                    updateIptvStatus('playing', player.iptvChannelName || 'OnlineTV');
                    player.iptvEl.play().then(() => {
                        debug('OnlineTV stream started' + (useProxy ? ' (via proxy)' : ''));
                        player.state = PlayerState.PLAYING;
                    }).catch(e => {
                        debug('OnlineTV play error: ' + e.message);
                        updateIptvStatus('error', 'Lecture impossible');
                    });
                });
                
                player.hlsInstance.on(Hls.Events.MANIFEST_LOADING, function() {
                    debug('Loading HLS manifest...');
                    updateIptvStatus('loading', 'Chargement...');
                });
                
                player.hlsInstance.on(Hls.Events.ERROR, function(event, data) {
                    debug('HLS Error: ' + data.type + ' - ' + data.details);
                    
                    if (data.fatal) {
                        switch(data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                debug('Network error, retrying in 2s...');
                                updateIptvStatus('retrying', 'Reconnexion...');
                                setTimeout(function() {
                                    if (player.hlsInstance) {
                                        player.hlsInstance.startLoad();
                                    }
                                }, 2000);
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                debug('Media error, trying to recover...');
                                updateIptvStatus('recovering', 'R√©cup√©ration...');
                                player.hlsInstance.recoverMediaError();
                                break;
                            default:
                                debug('Fatal HLS error, trying direct playback');
                                player.hlsInstance.destroy();
                                player.hlsInstance = null;
                                tryDirectPlayback(streamUrl);
                                break;
                        }
                    } else if (data.details === 'fragLoadError') {
                        debug('Fragment load error (non-fatal), continuing...');
                    } else if (data.details === 'manifestLoadError' || data.details === 'manifestParsingError') {
                        handleNetworkError(streamUrl, data, useProxy);
                    }
                });
                
                player.hlsInstance.on(Hls.Events.FRAG_LOADED, function() {
                    player.iptvRetryCount = 0;
                    updateIptvStatus('playing', player.iptvChannelName || 'OnlineTV');
                });
                
            } else if (player.iptvEl.canPlayType('application/vnd.apple.mpegurl')) {
                debug('Using native HLS support');
                player.iptvEl.src = effectiveUrl;
                player.iptvEl.play().then(() => {
                    debug('OnlineTV stream started (native)');
                    player.state = PlayerState.PLAYING;
                    updateIptvStatus('playing', player.iptvChannelName || 'OnlineTV');
                }).catch(e => {
                    debug('OnlineTV native play error: ' + e.message);
                    if (!useProxy) {
                        debug('Trying with proxy...');
                        loadHlsStream(streamUrl, true);
                    } else {
                        updateIptvStatus('error', 'Erreur de lecture');
                    }
                });
            } else {
                debug('No HLS support, trying direct playback');
                tryDirectPlayback(streamUrl);
            }
            
            document.getElementById('iptvInfo').style.display = 'block';
            document.getElementById('info').style.display = 'none';
            
            renderOverlays();
        }
        
        function handleNetworkError(streamUrl, data, currentlyUsingProxy = false) {
            player.iptvRetryCount++;
            
            if (player.iptvRetryCount <= player.iptvMaxRetries) {
                const delay = player.iptvRetryDelay;
                debug('Network error (' + data.details + '), retry ' + player.iptvRetryCount + '/' + player.iptvMaxRetries + ' in ' + (delay/1000) + 's');
                updateIptvStatus('retrying', 'Reconnexion ' + player.iptvRetryCount + '/' + player.iptvMaxRetries + '...');
                
                setTimeout(() => {
                    if (player.mode === 'iptv') {
                        if (player.hlsInstance) {
                            player.hlsInstance.destroy();
                            player.hlsInstance = null;
                        }
                        loadHlsStream(streamUrl, currentlyUsingProxy);
                    }
                }, delay);
            } else if (!currentlyUsingProxy) {
                debug('Direct connection failed, trying with CORS proxy...');
                player.iptvRetryCount = 0;
                updateIptvStatus('loading', 'Connexion via proxy...');
                
                setTimeout(() => {
                    if (player.mode === 'iptv') {
                        if (player.hlsInstance) {
                            player.hlsInstance.destroy();
                            player.hlsInstance = null;
                        }
                        loadHlsStream(streamUrl, true);
                    }
                }, 1000);
            } else {
                debug('Max retries reached, showing error');
                updateIptvStatus('error', 'Cha√Æne indisponible');
                showIptvError('La cha√Æne n\'est pas accessible. Causes possibles :<br><br>‚Ä¢ La cha√Æne est hors ligne ou prot√©g√©e<br>‚Ä¢ L\'URL du stream n\'est plus valide<br>‚Ä¢ Le serveur bloque les connexions externes<br><br>Essayez une autre cha√Æne ou v√©rifiez l\'URL M3U.');
            }
        }
        
        function updateIptvStatus(status, message) {
            const infoEl = document.getElementById('iptvInfo');
            const nameEl = document.getElementById('iptvChannelName');
            
            if (!infoEl || !nameEl) return;
            
            nameEl.textContent = message;
            
            infoEl.className = '';
            infoEl.style.cssText = 'display: block; position: fixed; top: 20px; left: 20px; backdrop-filter: blur(10px); padding: 12px 20px; border-radius: 8px; color: white; font-family: sans-serif; font-size: 14px; z-index: 60;';
            
            switch(status) {
                case 'loading':
                case 'retrying':
                case 'recovering':
                    infoEl.style.background = 'rgba(245, 158, 11, 0.9)';
                    break;
                case 'error':
                    infoEl.style.background = 'rgba(239, 68, 68, 0.9)';
                    break;
                case 'playing':
                default:
                    infoEl.style.background = 'rgba(0,0,0,0.7)';
                    break;
            }
        }
        
        function showIptvError(message) {
            let errorEl = document.getElementById('iptvError');
            if (!errorEl) {
                errorEl = document.createElement('div');
                errorEl.id = 'iptvError';
                errorEl.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 30px 40px; border-radius: 16px; text-align: center; color: white; font-family: sans-serif; z-index: 100; max-width: 400px;';
                document.body.appendChild(errorEl);
            }
            
            errorEl.innerHTML = `
                <div style="font-size: 48px; margin-bottom: 16px;">üì∫</div>
                <h3 style="font-size: 18px; margin-bottom: 8px;">Erreur de diffusion</h3>
                <p style="color: rgba(255,255,255,0.7); margin-bottom: 20px; font-size: 14px;">${message}</p>
                <button onclick="retryIptvStream()" style="background: #3b82f6; border: none; color: white; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 14px; margin-right: 8px;">
                    üîÑ R√©essayer
                </button>
                <button onclick="switchToPlaylistFromError()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 14px;">
                    üì∫ Playlist
                </button>
            `;
            errorEl.style.display = 'block';
        }
        
        function hideIptvError() {
            const errorEl = document.getElementById('iptvError');
            if (errorEl) {
                errorEl.style.display = 'none';
            }
        }
        
        function retryIptvStream() {
            hideIptvError();
            player.iptvRetryCount = 0;
            if (player.iptvUrl) {
                if (isHlsStream(player.iptvUrl)) {
                    debug('Retry: HLS stream');
                    loadHlsStream(player.iptvUrl, false);
                } else {
                    debug('Retry: MPEG-TS stream via proxy');
                    loadMpegTsStream(player.iptvUrl, true);
                }
            }
        }
        
        function switchToPlaylistFromError() {
            hideIptvError();
            switchToPlaylistMode();
            fetchPlaylist();
        }
        
        function tryDirectPlayback(streamUrl) {
            debug('Trying direct video playback');
            updateIptvStatus('loading', 'Lecture directe...');
            
            player.iptvEl.src = streamUrl;
            player.iptvEl.play().then(() => {
                debug('OnlineTV direct stream started');
                player.state = PlayerState.PLAYING;
                updateIptvStatus('playing', player.iptvChannelName || 'OnlineTV');
            }).catch(e => {
                debug('OnlineTV direct play error: ' + e.message);
                updateIptvStatus('error', 'Lecture impossible');
                showIptvError('Format de flux non support√©. Essayez une autre cha√Æne.');
            });
        }
        
        function switchToPlaylistMode() {
            if (player.hlsInstance) {
                player.hlsInstance.destroy();
                player.hlsInstance = null;
            }
            
            if (player.mpegtsPlayer) {
                player.mpegtsPlayer.destroy();
                player.mpegtsPlayer = null;
            }
            
            player.iptvEl.pause();
            player.iptvEl.removeAttribute('src');
            player.iptvEl.style.display = 'none';
            
            document.getElementById('iptvInfo').style.display = 'none';
            document.getElementById('info').style.display = '';
            
            player.iptvUrl = null;
            player.iptvChannelName = null;
            player.state = PlayerState.IDLE;
        }

        async function logPlay(item) {
            try {
                const response = await fetch('/player/api/log-play', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        content_id: item.id,
                        content_type: item.type,
                        category: item.category,
                        duration: item.duration,
                        booking_id: item.booking_id
                    })
                });
                
                const result = await response.json();
                if (result.exhausted) {
                    debug('Content exhausted, refreshing playlist');
                    fetchPlaylist();
                }
            } catch (error) {
                debug('Log play error: ' + error.message);
            }
        }

        async function sendHeartbeat() {
            const status = player.state === PlayerState.PAUSED ? 'paused' : 'playing';
            try {
                await fetch('/player/api/heartbeat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ status })
                });
                
                document.getElementById('statusDot').className = 'status-dot status-' + status;
                document.getElementById('statusText').textContent = 
                    player.state === PlayerState.PAUSED ? 'En pause' : 'En lecture';
            } catch (error) {
                document.getElementById('statusDot').className = 'status-dot status-offline';
                document.getElementById('statusText').textContent = 'Hors ligne';
            }
        }

        function togglePause() {
            if (player.state === PlayerState.PAUSED) {
                debug('Resuming playback');
                player.state = PlayerState.PLAYING;
                document.getElementById('pauseIcon').textContent = '‚è∏';
                
                if (player.playlist.length > 0) {
                    playCurrentItem();
                }
            } else {
                debug('Pausing playback');
                player.state = PlayerState.PAUSED;
                document.getElementById('pauseIcon').textContent = '‚ñ∂';
                
                clearTimer();
                player.videoEl.pause();
            }
            
            sendHeartbeat();
        }

        function renderOverlays() {
            const headerEl = document.getElementById('overlayHeader');
            const footerEl = document.getElementById('overlayFooter');
            const bodyEl = document.getElementById('overlayBody');
            const topLeftEl = document.getElementById('overlayTopLeft');
            const topRightEl = document.getElementById('overlayTopRight');
            const bottomLeftEl = document.getElementById('overlayBottomLeft');
            const bottomRightEl = document.getElementById('overlayBottomRight');
            const customEl = document.getElementById('overlayCustom');
            
            const allContainers = [headerEl, footerEl, bodyEl, topLeftEl, topRightEl, bottomLeftEl, bottomRightEl, customEl];
            allContainers.forEach(el => {
                if (el) {
                    el.style.display = 'none';
                    el.innerHTML = '';
                }
            });
            
            const overlays = player.overlays || [];
            debug('Rendering ' + overlays.length + ' overlays');
            
            overlays.forEach(overlay => {
                if (!overlay.is_active) {
                    debug('Skipping inactive overlay: ' + overlay.id);
                    return;
                }
                
                let container;
                let position = overlay.position || 'footer';
                const positionMode = overlay.position_mode || 'linear';
                const cornerPosition = overlay.corner_position || 'top_left';
                
                if (position === 'corner' && cornerPosition) {
                    position = cornerPosition;
                }
                
                if (position === 'header') {
                    container = headerEl;
                } else if (position === 'footer') {
                    container = footerEl;
                } else if (position === 'body') {
                    container = bodyEl;
                } else if (position === 'top_left') {
                    container = topLeftEl;
                } else if (position === 'top_right') {
                    container = topRightEl;
                } else if (position === 'bottom_left') {
                    container = bottomLeftEl;
                } else if (position === 'bottom_right') {
                    container = bottomRightEl;
                } else if (position === 'custom') {
                    container = customEl;
                    if (customEl) {
                        const posX = overlay.image_pos_x || 50;
                        const posY = overlay.image_pos_y || 50;
                        customEl.style.left = posX + '%';
                        customEl.style.top = posY + '%';
                        customEl.style.transform = 'translate(-50%, -50%)';
                    }
                } else {
                    container = bodyEl;
                }
                
                if (!container) {
                    debug('Container not found for position: ' + position);
                    return;
                }
                
                container.style.display = 'block';
                
                if (overlay.type === 'ticker') {
                    container.style.backgroundColor = overlay.background_color || '#000000';
                    const duration = Math.max(10, (overlay.message?.length || 50) / (overlay.scroll_speed / 10));
                    container.innerHTML = `
                        <div class="overlay-ticker" style="
                            color: ${overlay.text_color || '#ffffff'};
                            font-size: ${overlay.font_size || 24}px;
                            animation-duration: ${duration}s;
                        ">${overlay.message || ''}</div>
                    `;
                } else if (overlay.type === 'image' && overlay.image_path) {
                    const opacity = overlay.image_opacity !== undefined ? overlay.image_opacity : 1;
                    const widthPercent = overlay.image_width_percent || 20;
                    
                    if (position === 'header' || position === 'footer' || position === 'body') {
                        container.innerHTML = `<img src="/${overlay.image_path}" class="overlay-image" style="opacity: ${opacity}; max-width: ${widthPercent}%;" />`;
                    } else {
                        const cornerSize = overlay.corner_size || 15;
                        container.innerHTML = `<img src="/${overlay.image_path}" style="opacity: ${opacity}; width: ${widthPercent}vw; max-width: 300px; height: auto;" />`;
                    }
                } else if (overlay.type === 'corner' && overlay.image_path) {
                    const opacity = overlay.image_opacity !== undefined ? overlay.image_opacity : 1;
                    const cornerSize = overlay.corner_size || 15;
                    container.innerHTML = `<img src="/${overlay.image_path}" style="opacity: ${opacity}; width: ${cornerSize}vw; max-width: 200px; height: auto;" />`;
                }
                
                debug('Rendered overlay: id=' + overlay.id + ', type=' + overlay.type + ', position=' + position);
            });
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        function logout() {
            window.location.href = '/player/logout';
        }

        async function startPlayer() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('loading').classList.remove('hidden');
            
            player.imageEl = document.getElementById('imageContent');
            player.videoEl = document.getElementById('videoContent');
            player.iptvEl = document.getElementById('iptvContent');
            player.debugEl = document.getElementById('debugInfo');
            
            debug('Player starting...');
            
            await fetchPlaylist();
            
            document.getElementById('loading').classList.add('hidden');
            
            player.heartbeatInterval = setInterval(sendHeartbeat, 30000);
            sendHeartbeat();
            
            player.refreshInterval = setInterval(fetchPlaylist, player.PLAYLIST_REFRESH_INTERVAL);
            
            if (player.playlist.length > 0) {
                debug('Starting playback with ' + player.playlist.length + ' items');
                player.currentIndex = 0;
                playCurrentItem();
            } else {
                debug('No content available');
                updateInfoDisplay(null);
            }
        }

        document.addEventListener('mousemove', showControls);
        document.addEventListener('mousedown', showControls);
        document.addEventListener('keydown', (e) => {
            showControls();
            if (e.key === ' ' || e.key === 'p') {
                e.preventDefault();
                togglePause();
            } else if (e.key === 'f' || e.key === 'F11') {
                e.preventDefault();
                toggleFullscreen();
            } else if (e.key === 'n') {
                e.preventDefault();
                debug('Manual skip');
                advanceToNext();
            }
        });

        window.addEventListener('beforeunload', () => {
            clearTimer();
            if (player.heartbeatInterval) clearInterval(player.heartbeatInterval);
            if (player.refreshInterval) clearInterval(player.refreshInterval);
        });
    </script>
</body>
</html>
